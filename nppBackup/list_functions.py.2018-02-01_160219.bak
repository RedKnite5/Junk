import mod, sys, math, random, itertools, hashlib, pickle

"""
cd dropbox
cd python

"""


words = pickle.load(open("list_of_Eng_words.txt","rb"))
ascii_charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`~!@#$%^&*()-_=+[{]}\|;:'\",<.>/? "
lowercase = "abcdefghijklmnopqrstuvwxyz"
uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
numbers_set = "0123456789"
symbols_set = "`~!@#$%^&*()-_=+[{]}\|;:'\",<.>/? " 
pi = 3.1415926535897
tau = 6.2831853071796
e = 2.71828182846
phi = 1.61803398875




class rational:
	def __init__(self, max=10):
		self.max = max
		self.dir = "up"
	
	def __iter__(self):
		self.a = 0
		self.b = 1
		return(self)
		
	def __next__(self):
		ans = self.a / self.b
		
		if self.a == self.max:
			raise StopIteration
		
		if self.a == 1 and self.dir == "down":
			self.b += 1
			self.dir = "up"
		elif self.b == 1 and self.dir == "up":
			self.a += 1
			self.dir = "down"
		else:
			if self.dir == "down":
				self.a -= 1
				self.b += 1
			if self.dir == "up":
				self.a += 1
				self.b -= 1
				
		return((self.a,self.b))




def instructions():
	inst = open("mod_instructions.txt","r")
	print(inst.read())
	inst.close()
	return

def parse(text, *arg):
	s = " "
	if len(arg) > 0:
		s = arg[0]
	return(text.split(s))
	
def factorize(num):
	fac=abs(num)
	factors = []
	for i in range(1,math.ceil(fac**.5)+1):
		if fac%i==0:
			factors.append(i)
			if (fac/i) not in factors:
				factors.append(int(fac/i))
	factors.sort()
	return(factors)
	
def quad_form(quad_a, quad_b, quad_c):
	quad_form_ans = []
	rand = ((quad_b**2) - 4*quad_a*quad_c)**.5
	quad_form_ans.append(((-1*quad_b)+rand)/(2*quad_a))
	quad_form_ans.append(((-1*quad_b)-rand)/(2*quad_a))
	return quad_form_ans
	
def un_pyth(a,c):
	b_sqrd = (c**2)-(a**2)
	b = b_sqrd**.5
	return b

def insert_string(main_str,insert,place):
	result = ""		
	if place>0:
		for i in itertools.islice(main_str,0,place):
			result += i
	result+=insert
	for i in itertools.islice(main_str,place,len(main_str)):
		result += i
	print(result)

def factorial(n):
	ans = 1
	for i in range(1,n+1):
		ans = ans * i
	return ans
	
def permute(n,r):
	if r > n:
		raise ValueError("second argument: %d is greater than first argument: %d"%(r,n))
	else:
		ans = factorial(n)/factorial(n-r)
		return ans
		
def choose(n,r):
	if r > n:
		raise ValueError("second argument: %d is greater than first argument: %d"%(r,n))
	else:
		ans = permute(n,r)/factorial(r)
		return ans
	
def rand_str(*arg):
	if len(arg) > 0:
		length = arg[0]
	else:
		length = 4
	if len(arg) > 1:
		charset = arg[1]
	else:
		charset = lowercase
		
	set_size = len(charset)
	string = ""
	for i in range(length):
		string += charset[random.randint(0,set_size-1)]
	return string
	
def start_substr(substr,string):
	if substr not in string:
		raise ValueError("Substring not in string.")
	for i in range(len(string)):
		if substr[0] == string[i]:
			start = True
			for j in range(len(substr)):
				if substr[j] != string[i+j]:
					start = False
			if start == True:
				return i

def str_start(begin,string,*args):
	if len(args) > 0:
		place = args[0]
	bool = True
	for num,letter in enumerate(begin,place):
		try:
			if letter != string[num]:
				bool = False
		except:
			bool = False
			break
	return bool
	
		
def overlap(a,b): #finds overlap between intervals
	return max(0, min(a[1], b[1]) - max(a[0], b[0]))
	
def find_center(item):
	c = a.coords(item)
	if len(c) == 4:
		x = (c[0]+c[2])/2
		y = (c[1]+c[3])/2
		return(x,y)
	else:
		raise ValueError

def num_to_color(number,max=100):
	color = colorsys.hls_to_rgb(number/max,100,1)
	ans = list(map(lambda c: str(hex(int(c)))[2:],color))
	for i in range(len(ans)):
		if len(ans[i]) == 1:
			ans[i] = "0"+ans[i]
	ans = "#"+"".join(ans)
	return(ans)
	
def div(inter,pieces):
	ans = []
	for i in range(pieces):
		first = inter[0]+i*(inter[1]-inter[0])/pieces
		second = inter[0]+(i+1)*(inter[1]-inter[0])/pieces
		ans.append([first,second])
	return(ans)

def rect(par = [[0,1]], point = "m", y = lambda a:a):
	area = 0
	for i in par:
		if point in ("m","mid","midpoint"):
			x_val = (i[0]+i[1])/2
		elif point in ("l","left","left end point"):
			x_val = i[0]
		elif point in ("r","right","right end point"):
			x_val = i[1]
	
		area += (i[1]-i[0])*y(x_val)
	return(area)
	
def trap(par = [[0,1]], y = lambda a:a):
	area = 0
	for i in par:
		area += (i[1]-i[0])*(y(i[0])+y(i[1]))/2
	return(area)
	
def simp(par=[[0,1]], y = lambda a:a):
	area = 0
	for i in par:
		area += ((i[1]-i[0])/6) * (y(i[0]) + 4*y((i[0]+i[1])/2) + y(i[1]))
	return(area)
	
def sigmoid(x): return(1/(1+e**(-1*x)))

def comp_abs(x): return((x.real*x.real+x.imag*x.imag)**.5)
	
def html_color(color):
	ans = list(map(lambda c: str(hex(int(c)))[2:],color))
	for i in range(len(ans)):
		if len(ans[i]) == 1:
			ans[i] = "0"+ans[i]
	return("#"+"".join(ans))

def sinh(x): return(((e**x)-(e**(-1*x)))/2)
	
def cosh(x):
	"""Return the hyperbolic cosine of x."""
	
	return(((e**x)+(e**(-1*x)))/2)
	
def hype(a,b,n):
	"""The Hyperion sequence implemented recursivly."""
	
	if n == 0:
		return(b+1)
	elif n == 1 and b == 0:
		return(a)
	elif n == 2 and b == 0:
		return(0)
	elif n >= 3 and b == 0:
		return(1)
	else:
		return(hype(a,hype(a,b-1,n),n-1))

def find_indecies(string,sub):
	"""Generate the starting indeces of a substing in a string."""
	
	last = -1
	while True:
		last = string.find(sub,last+1)
		if last == -1:
			break
		yield(last)
		

def _brackets(s):
	"""Inform separate whether parentheses match."""
	
	x = 0
	for i in s:
		if i == "(":
			x += 1
		elif i == ")":
			x -= 1
	return(x)

def separate(s,splitter=","):
	"""Split up arguments of a function with commas
	like mod(x,y) or log(x,y) based on where commas that are only
	in one set of parentheses.
	"""
	
	# separate based on all commas
	terms = s.split(splitter)
	
	new_terms = []
	middle = False
	
	# iterate of over the groups separated by commas
	for i in range(len(terms)):
		
		# check if it is in the middle of a group of parentheses
		if middle == False:
			next_term = terms[i]
		
		# reevaluate if its in the middle of parentheses
		x = _brackets(next_term)
		
		# if its not in the middle add the curren term to final list
		if x == 0:
			new_terms.append(terms[i])
			continue
		
		# if it is in the middle of a group
		if x > 0:
			
			# add the current term to the string of previous terms
			next_term = next_term + splitter + terms[i+1]
			
			# check if that was the end of the group
			if _brackets(next_term) == 0:
				new_terms.append(next_term)
				
				# stop thinking its in the middle of parentheses
				middle = False
			else:
				# start thinking its in the middle of parentheses
				middle = True
	
	return(new_terms)


